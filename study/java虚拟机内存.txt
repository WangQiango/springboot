1. java文件编译过程
	程序员编写.java文件---->由javac编译成.class文件---->有虚拟机JVM编译成电脑认识的二级制文件
	
2. javac是什么？
	javac是java语言编程编译器(编译程序)，全称java compiler，javac工具读java编写的类和接口，编译成字节码代码的class文件。
	javac无需考虑机器所在平台，只需要供jvm编译处理，由jvm再编译成机器可以识别的机器码。这也是java可以实现跨平台的原理。

3. javac编译器的基本结构？（如何编译程序呢）
	首先，进行词法分析，读取源码的时候，一个字节一个字节的读进来，找出哪些字节是语法关键词，哪些不是；
	然后，进行语法分析，检查这些关键词组合在一起时是否符合java语法规范，比如if后面必须跟着一个布尔判断；
	之后，进行语义分析，把一些难懂的复杂的语法转化为最简洁的语法
	最后，通过字节码生成器生产字节码，也就是将一个数据结构转化为另一个数据结构。就像是所有中文词语翻译成英文后再组装成句子。
	javac的各个模块完成了将java源代码转化成java字节码的任务，所以javac有四个模块：
	词法分析器    语法分析器      语义分析器       代码生成器
	
4. JVM有哪些部分组成？运行流程是什么？ 
	JVM包含两个子系统：类加载系统（Classes loader）、执行引擎（Execution engine）
		   两个组件：JVM运行时数据区（Runtime data area）、本地接口（Native Interface）
	流程：首先通过编译器将java文件编译成class文件，类加载器将其加载到内存中，放到运行时数据区中的方法区内。字节码文件只是JVM的一套指令集规范，
		  并不能直接被底层操作系统所执行，所以需要特定的命令解析器执行引擎，将字节码翻译成底层系统指令，再交由CPU去执行，在此过程中还需要调用
		  其他语言的本地接口库来实现整个程序的功能。

5. 说一下Java运行时数据区？
    Java运行时区域分为：程序计数器、虚拟机栈、本地方法栈（前三者是线程私有的数据区）、方法区和堆（后两者是线程共有的数据区）
	1）、程序计数器：此区域是线程私有的，保存的是每个线程执行的字节码的行号，以便CPU切换线程之后能够继续正确的执行，由于线程没有记忆功能，所以需要程序计数器。程序计数器是一块较小的内存，也是虚拟机中唯一一块没有内存溢出情况的区域。
	2）、虚拟机栈：属于线程私有，生命周期和线程一致。描述的是Java方法执行的内存模型，每个方法执行的同时都会在虚拟机栈中创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。栈帧也是虚拟机栈的下一个单位，其中局部变量存储就是临时的八个基本数据和对象引用的地址和return address类型；操作数栈就是用来操作的读取代码进行计算将计算结果放到局部变量表中去；动态链接是如果当前方法中调用了其他的方法，那么就会在这里存储其他方法的链接；方法出口正常的就是return，不正常就是抛出异常。
	
6. 一个方法调用另一个方法会创建很多栈帧吗？
	会。一个栈帧中有动态链接调用另一个方法，就会在虚拟机栈中创建一个新的栈帧，这个栈帧会披在调用者后面。递归方法同理。
	
7. 栈指向堆是什么意思？ 	
	就是栈中要使用成员变量的时候不会存储成员变量，而是存储一个应用地址。
	
8. 简单介绍一下Java堆？
	Java堆是虚拟机中最大的一块内存，随着虚拟机的启动而创建，是被所有线程所共享的一块区域。此内存区域的唯一目的就是存放对象实例，所有的对象实例及数组都要在堆上分配。java堆是垃圾收集器管理的主要区域，也被称为GC堆。从垃圾回收角度来看Java堆可以分为年轻代和老生带。从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。Java堆可以处以物理上不连续的内存空间中，内存的大小是可以配置的。如果堆中没有足够的的内存来分配对象实例，且堆也无法再扩展，GC也没用的时候会抛出OutOfMemoryError异常。

9. 本地方法栈：和栈很像，但是加上了native关键字；他是虚拟机栈为虚拟机执行Java方法的服务方法；native关键字的方法是看不到的，且native修饰的大部分源码都是c和c++的代码。
	所以本地方法栈就是虚拟机栈为虚拟机提供的执行Java代码的c或c++代码的方法。
	
10. 解释一下方法区？
	方法区是所有线程共享的内存区域，用于存放已经被Java虚拟机加载的类信息，常亮、静态变量、编译器编译后的代码等数据；也叫非堆，从内存回收的角度看叫永久代。
	
11. 什么是JVM字节码执行引擎？
	虚拟机核心的组件就是执行引擎，负责执行虚拟机的字节码。
	
12. 垃圾收集系统GC？
	程序在运行过程中，会产生大量的内存垃圾（一些没有引用指向的内存对象），为了能够确保运行性能，Java虚拟机在程序运行的过程中会不断的进行自动的垃圾回收GC。
	
13. Java会存在内存泄漏吗为什么？（可达、无用）
	 内存泄漏是指不在被使用到的对象或者变量一直在占据内存，理论上来说Java的垃圾回收机制会回收掉。但是当Java中被分配的对象满足可达的即在有向图中存在通路可以与其连接，但是这些对象是无用的，即程序以后不会在使用这些对象，就被判定为内存泄漏。
	 
14. 简述Java垃圾回收机制GC？
	 垃圾回收机制在JVM中有一个垃圾回收线程，他是低优先级的，当虚拟机空闲或者当前堆空间内存不足时才会触发执行，扫描那些没有被任何引用的对象，将他们进行回收。
	 优点：无需程序员手动回收处理无引用的对象；
	 缺点：程序员不能实时的对某个对象调用垃圾回收。
	 
15. 垃圾回收器的原理？
	当程序员创建对象时，GC就开始监控这个对象的地址大小以及使用情况，通常情况下采用有向图的方式记录和管理堆中的所有对象，确定哪些对象时可达的，哪些对象时不可达的，GC会将确定的不可达的对象进行回收。
	
	即使程序员手动执行System.gc()方法，但是也不一定会执行。
	
16. JVM垃圾回收的算法有哪些？
	标记-清除
	标记-整理
	复制算法
	分代算法：年轻代采用复制算法，老年代采用标记整理算法。
	
17. 分代算法：根据对象的存活周期将内存划分为几块：年轻代、老年代和永久代。
	其中年轻代分为Eden区和两个Survivor区，大小比为8：1：1，这个区域存放的是生命周期较短的对象实例。每次发生Minor GC时会有大量的对象被回收，所以采用复制算法效率高。当Eden的内存满了时或者新建的对象大小大于剩下的内存时就会发生Minor GC，此时没有被回收的对象会被复制到Survivor1中，当下次Minor GC时，Eden存活下来的对象实例和Survivor1中的对象就会全部复制到Survivor中，Eden和Survivor1清空，这样可以解决碎片化的问题。当Survivor中的对象连续经过15次Minor GC后，S1中的对象会被送到老年代，这可以减少被送到老年代的对象，进而减少Full GC的发生。
	执行流程：
	把 Eden + From Survivor 存活的对象放入 To Survivor 区；
	清空 Eden 和 From Survivor 分区；
	From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。
	
	老年代中存放占用较大内存的对象和存活时间长的对象，垃圾回收算法采用标记-整理算法，Major GC执行速度慢，当老年代的剩余空间不足的时候，或执行System.gc()、堆内存分配很大对象的时候会执行Major GC。
	
18. 内存分配策略：
	多数情况下，对象在年轻代的Eden区分配。当Eden区没有足够的空间进行分配时，虚拟机就会执行一次Minor GC，如果本次GC执行完之后还是没有足够的空间，则将启动分配担保机制在老年代中分配内存。
	
19. 虚拟机类加载机制？
	虚拟机把描述类的数据从Class文件中加载到内存，并对数据进行校验、解析和初始化最终形成可以被虚拟机直接使用的Java类型。
20.